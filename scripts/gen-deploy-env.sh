#!/usr/bin/env bash
set -euo pipefail

# 生成可“导入平台”的 env 文件（本地用，不提交）
# - Render: deploy/render.env
# - Vercel: deploy/vercel.env
#
# 中文注释:
# - 会从 `.env` / `backend/.env` / `frontend/.env.local` 读取已存在的值（若有）。
# - 出于安全考虑：脚本只写文件，不把密钥 echo 到 stdout。

ROOT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)"
OUT_DIR="${ROOT_DIR}/deploy"
mkdir -p "${OUT_DIR}"

warn() {
  printf "WARN: %s\n" "$*" 1>&2
}

_read_var_from_file() {
  local file="$1"
  local key="$2"
  if [ ! -f "$file" ]; then
    return 1
  fi
  # 只取最后一次出现的 KEY=... 行（避免重复定义）
  local line
  line="$(rg -n --no-heading "^${key}=" "$file" | tail -n 1 | sed -E 's/^[0-9]+://')"
  if [ -z "$line" ]; then
    return 1
  fi
  printf "%s" "${line#*=}"
  return 0
}

get_var() {
  local key="$1"
  local v=""

  # 优先 backend/.env（后端最完整）
  v="$(_read_var_from_file "${ROOT_DIR}/backend/.env" "$key" 2>/dev/null || true)"
  if [ -n "$v" ]; then
    printf "%s" "$v"
    return 0
  fi

  # 其次 root .env
  v="$(_read_var_from_file "${ROOT_DIR}/.env" "$key" 2>/dev/null || true)"
  if [ -n "$v" ]; then
    printf "%s" "$v"
    return 0
  fi

  # 最后 frontend/.env.local
  v="$(_read_var_from_file "${ROOT_DIR}/frontend/.env.local" "$key" 2>/dev/null || true)"
  if [ -n "$v" ]; then
    printf "%s" "$v"
    return 0
  fi

  printf ""
}

set_kv() {
  local key="$1"
  local value="$2"
  # 不做复杂转义；假设值不包含换行（平台 env 也不接受换行）
  printf "%s=%s\n" "$key" "$value"
}

render_env="${OUT_DIR}/render.env"
vercel_env="${OUT_DIR}/vercel.env"

supabase_url="$(get_var "SUPABASE_URL")"
supabase_anon_key="$(get_var "SUPABASE_ANON_KEY")"
if [ -z "$supabase_anon_key" ]; then
  # 兼容旧变量名
  supabase_anon_key="$(get_var "SUPABASE_KEY")"
fi
supabase_service_key="$(get_var "SUPABASE_SERVICE_ROLE_KEY")"

next_public_supabase_url="$(get_var "NEXT_PUBLIC_SUPABASE_URL")"
next_public_supabase_anon_key="$(get_var "NEXT_PUBLIC_SUPABASE_ANON_KEY")"

backend_origin="$(get_var "BACKEND_ORIGIN")"
frontend_origin="$(get_var "FRONTEND_ORIGIN")"

hf_endpoint="$(get_var "HF_ENDPOINT")"
if [ -z "$hf_endpoint" ]; then
  hf_endpoint="https://hf-mirror.com"
fi

# Render（后端）
{
  printf "# Generated by ./scripts/gen-deploy-env.sh (DO NOT COMMIT)\n"
  printf "# Render Backend env\n\n"
  set_kv "GO_ENV" "prod"

  set_kv "SUPABASE_URL" "${supabase_url}"
  set_kv "SUPABASE_ANON_KEY" "${supabase_anon_key}"
  set_kv "SUPABASE_SERVICE_ROLE_KEY" "${supabase_service_key}"

  # CORS
  set_kv "FRONTEND_ORIGIN" "${frontend_origin}"

  # MVP defaults
  set_kv "PLAGIARISM_CHECK_ENABLED" "0"
  set_kv "PRODUCTION_GATE_ENABLED" "0"

  # Matchmaking / HF
  set_kv "MATCHMAKING_WARMUP" "1"
  set_kv "MATCHMAKING_LOCAL_FILES_ONLY" "0"
  set_kv "HF_ENDPOINT" "${hf_endpoint}"
} > "${render_env}"

# Vercel（前端）
{
  printf "# Generated by ./scripts/gen-deploy-env.sh (DO NOT COMMIT)\n"
  printf "# Vercel Frontend env\n\n"

  # Supabase public vars
  set_kv "NEXT_PUBLIC_SUPABASE_URL" "${next_public_supabase_url:-$supabase_url}"
  set_kv "NEXT_PUBLIC_SUPABASE_ANON_KEY" "${next_public_supabase_anon_key:-$supabase_anon_key}"

  # Next rewrites -> backend
  set_kv "BACKEND_ORIGIN" "${backend_origin}"
} > "${vercel_env}"

# 校验缺失项（只提示，不打印值）
if [ -z "$supabase_url" ]; then warn "SUPABASE_URL missing"; fi
if [ -z "$supabase_anon_key" ]; then warn "SUPABASE_ANON_KEY missing"; fi
if [ -z "$supabase_service_key" ]; then warn "SUPABASE_SERVICE_ROLE_KEY missing (Render backend will fail)"; fi
if [ -z "$frontend_origin" ]; then warn "FRONTEND_ORIGIN missing (Render CORS will block Vercel requests)"; fi
if [ -z "$backend_origin" ]; then warn "BACKEND_ORIGIN missing (Vercel rewrites will point to nowhere)"; fi

printf "OK: wrote %s\n" "${render_env}"
printf "OK: wrote %s\n" "${vercel_env}"

